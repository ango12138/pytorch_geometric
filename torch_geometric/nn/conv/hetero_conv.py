from typing import Dict, Union, Optional
from torch_geometric.typing import NodeType, EdgeType

from collections import defaultdict

import torch
from torch import Tensor
from torch.nn import Module
from torch_geometric.nn.conv.hgt_conv import group


class HeteroConv(Module):
    r"""A generic wrapper for computing graph convolution on heterogeneous
    graphs.
    This layer will pass messages from source nodes to target nodes based on
    the bipartite GNN layer given for a specific edge type.
    If multiple relations point to the same destination, their results will be
    aggregated according to :obj:`aggr`.

    ..code-block:: python

        hetero_conv = HeteroConv({
            ('paper', 'cites', 'paper'): GCNConv(-1, 64),
            ('author', 'writes', 'paper'): SAGEConv(-1, 64),
            ('paper', 'written_by', 'author'): GATConv(-1, 64),
        }, aggr='sum')

        out_dict = hetero_conv(data.x_dict, data.edge_index_dict)

        print(list(out_dict.keys()))
        >>> ['paper', 'author']

    Args:
        convs (Dict[Tuple[str, str, str], Module]): A dictionary
            holding a bipartite
            :class:`~torch_geometric.nn.conv.MessagePassing` layer for each
            individual edge type.
        aggr (string, optional): The aggregation scheme to use for grouping
            node embeddings generated by different relations.
            (:obj:`"sum"`, :obj:`"mean"`, :obj:`"min"`, :obj:`"max"`).
            (default: :obj:`"sum"`)

    """
    def __init__(self, convs: Dict[EdgeType, Module], aggr: str = "sum"):
        super().__init__()
        self.convs = convs
        # place in ModuleList to include all parameters of the convs in the Module
        self.modules = torch.nn.ModuleList(convs.values())
        self.aggr = aggr

    def reset_parameters(self):
        for conv in self.convs.values():
            conv.reset_parameters()

    def forward(
        self,
        x_dict: Dict[NodeType, Tensor],
        edge_index_dict: Union[Dict[EdgeType, Tensor], Dict[EdgeType, Tensor]],
        edge_weight_dict: Optional[Dict[EdgeType, Tensor]] = None,
        edge_attr_dict: Optional[Dict[EdgeType, Tensor]] = None,
    ) -> Dict[NodeType, Tensor]:
        r"""
        Args:
            x_dict (Dict[str, Tensor]): A dictionary holding node feature
                information for each individual node type.
            edge_index_dict (Dict[Tuple[str, str, str], Tensor]): A dictionary
                holding graph connectivity information for each individual
                edge type.
            edge_weight_dict (Dict[Tuple[str, str, str], Tensor], optional): A
                dictionary holding one-dimensional edge weight information
                for individual edge types. (default: :obj:`None`)
            edge_attr_dict (Dict[Tuple[str, str, str], Tensor], optional): A
                dictionary holding multi-dimensional edge feature information
                for individual edge types. (default: :obj:`None`)
        """

        out_dict = defaultdict(list)
        for key, conv in self.convs.items():
            src, _, dst = key

            kwargs = {}
            if edge_weight_dict is not None and key in edge_weight_dict:
                kwargs['edge_weight'] = edge_weight_dict[key]
            if edge_weight_dict is not None and key in edge_attr_dict:
                kwargs['edge_attr'] = edge_attr_dict[key]

            if src == dst:
                out = conv(x=x_dict[src], edge_index=edge_index_dict[key],
                           **kwargs)
            else:
                out = conv(x=(x_dict[src], x_dict[dst]),
                           edge_index=edge_index_dict[key], **kwargs)

            out_dict[dst].append(out)

        for key, values in out_dict.items():
            out_dict[key] = group(values, self.aggr)

        return out_dict
    
    @staticmethod
    def forward_op(x, module_dict, **kwargs):
        r"""A helper function for the heterogeneous operations. Given a dictionary input
        `x`, it will return a dictionary with the same keys and the values applied by the
        corresponding values of the `module_dict` with specified parameters. The keys in `x` 
        are same with the keys in the `module_dict`.
        Args:
            x (Dict[str, Tensor]): A dictionary that the value of each item is a tensor.
            module_dict (:class:`torch.nn.ModuleDict`): The value of the `module_dict` 
                will be fed with each value in `x`.
            **kwargs (optional): Parameters that will be passed into each value of the 
                `module_dict`.
        """
        if not isinstance(x, dict):
            raise ValueError("The input x should be a dictionary.")
        res = {}
        for key in x:
            res[key] = module_dict[key](x[key], **kwargs)
        return res

    def __repr__(self) -> str:
        return f'{self.__class__.__name__}(num_relations={len(self.convs)})'
